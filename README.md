# Intrusion detection with suricata Zoly
## Task 1
La acest task, am inceput prin a retine in registrul ecx id-ul furnicii, pentru a putea accesa pozitia ecx din vectorul ant_permissions. Stocam aceasta valoare in edx. In eax dorim sa pastram doar ce sali doreste furnica sa rezerve, scapand de id-ul ei, asa ca mutam la stanga 8 biti, apoi iar la dreapta, pentru a ii face 0 pe primii 8. Am dedus ca pentru a permite furnicii sa rezerve toate salile pe care le doreste, ea nu trebuie sa isi doreasca o singura sala la care nu are permisiune. Cu ale cuvinte, un and logic intre multimea permisiunilor si multimea dorintelor, trebuie sa fie egal cu multimea dorintelor.
## Task 3
La fiecare task, am implementat un fel de "for" in "for" pentru fiecare runda, respectiv fiecare byte. Pentru a itera in ambele cu registrul ecx, la fiecare pas din primul "for" il punem pe stiva la inceput si il scoatem la final
### Encriptie
In al e tul initial. In continuare, urmam pasii descrisi, iar pentru a face modulul am facut and logic cu 7 pentru ca 7 in baza 2 e 111.
### Decriptie
La decriptie am parcurs in al doilea "for" cu instructiunea loop pentru ca nu mai aveam nevoie sa luam bytesii in ordine crescatoare
## Task 4
La inceput, am salvat valorile oferite prin registrii in variabile declarate in sectiunea .bss pentru a elibera registrii ca sa ii pot folosi, cu mentiunea ca n si m le-am salvat ca n - 1 si m - 1, pentru ca singura data cand le folosim este atunci cand verificam daca am iesit din labirint si avem nevoie de ele scazute cu 1 datorita indexarii de la 0. In eticheta in_labyrinth, destul de intutitiv, ramanem pana cand nu gasim o iesire. Primul lucru trebuie sa punem 1 pe valoarea curenta ca sa nu cumva sa ne intoarcem. Apoi, verific conditiile de break, si anume daca am atins n - 1 sau m - 1. Continuam, verificand celulele din stanga, dreapta, sus si jos. Aceste directii sunt stocate in vectorii dir_x si dir_y, pe care ii parcurgem paralel cu ajutorul registrului ecx, pe care il incrementam la fiecare pas. Nu am considerat necesar sa verific ca ecx sa nu depaseasca marimea vectorilor pentru ca se garanteaza ca nu exista fundaturi. Odata ce am gasit pozitia pe care ne putem deplasa, modificam variabilele cur_x si cur_y care ne indica la ce pozitie ne aflam. In final, recuperam de pe stiva adresele la care trebuie sa returnam valorile cerute si le incarcam cu valorile obtinute.